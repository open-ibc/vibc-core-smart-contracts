/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common";

export type IbcEndpointStruct = { portId: string; channelId: BytesLike };

export type IbcEndpointStructOutput = [portId: string, channelId: string] & {
  portId: string;
  channelId: string;
};

export type HeightStruct = {
  revision_number: BigNumberish;
  revision_height: BigNumberish;
};

export type HeightStructOutput = [
  revision_number: bigint,
  revision_height: bigint
] & { revision_number: bigint; revision_height: bigint };

export type IbcPacketStruct = {
  src: IbcEndpointStruct;
  dest: IbcEndpointStruct;
  sequence: BigNumberish;
  data: BytesLike;
  timeoutHeight: HeightStruct;
  timeoutTimestamp: BigNumberish;
};

export type IbcPacketStructOutput = [
  src: IbcEndpointStructOutput,
  dest: IbcEndpointStructOutput,
  sequence: bigint,
  data: string,
  timeoutHeight: HeightStructOutput,
  timeoutTimestamp: bigint
] & {
  src: IbcEndpointStructOutput;
  dest: IbcEndpointStructOutput;
  sequence: bigint;
  data: string;
  timeoutHeight: HeightStructOutput;
  timeoutTimestamp: bigint;
};

export type OpIcs23ProofPathStruct = { prefix: BytesLike; suffix: BytesLike };

export type OpIcs23ProofPathStructOutput = [prefix: string, suffix: string] & {
  prefix: string;
  suffix: string;
};

export type OpIcs23ProofStruct = {
  path: OpIcs23ProofPathStruct[];
  key: BytesLike;
  value: BytesLike;
  prefix: BytesLike;
};

export type OpIcs23ProofStructOutput = [
  path: OpIcs23ProofPathStructOutput[],
  key: string,
  value: string,
  prefix: string
] & {
  path: OpIcs23ProofPathStructOutput[];
  key: string;
  value: string;
  prefix: string;
};

export type Ics23ProofStruct = {
  proof: OpIcs23ProofStruct[];
  height: BigNumberish;
};

export type Ics23ProofStructOutput = [
  proof: OpIcs23ProofStructOutput[],
  height: bigint
] & { proof: OpIcs23ProofStructOutput[]; height: bigint };

export type ChannelEndStruct = {
  portId: string;
  channelId: BytesLike;
  version: string;
};

export type ChannelEndStructOutput = [
  portId: string,
  channelId: string,
  version: string
] & { portId: string; channelId: string; version: string };

export type ChannelStruct = {
  version: string;
  ordering: BigNumberish;
  feeEnabled: boolean;
  connectionHops: string[];
  counterpartyPortId: string;
  counterpartyChannelId: BytesLike;
  portId: string;
};

export type ChannelStructOutput = [
  version: string,
  ordering: bigint,
  feeEnabled: boolean,
  connectionHops: string[],
  counterpartyPortId: string,
  counterpartyChannelId: string,
  portId: string
] & {
  version: string;
  ordering: bigint;
  feeEnabled: boolean;
  connectionHops: string[];
  counterpartyPortId: string;
  counterpartyChannelId: string;
  portId: string;
};

export type AckPacketStruct = { success: boolean; data: BytesLike };

export type AckPacketStructOutput = [success: boolean, data: string] & {
  success: boolean;
  data: string;
};

export interface IDispatcherInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "acknowledgement"
      | "channelCloseConfirm"
      | "channelCloseInit"
      | "channelOpenAck"
      | "channelOpenConfirm"
      | "channelOpenInit"
      | "channelOpenTry"
      | "feeVault"
      | "getChannel"
      | "getOptimisticConsensusState"
      | "portPrefix"
      | "recvPacket"
      | "removeConnection"
      | "sendPacket"
      | "setClientForConnection"
      | "setPortPrefix"
      | "timeout"
      | "updateClientWithOptimisticConsensusState"
      | "writeTimeoutPacket"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "Acknowledgement"
      | "AcknowledgementError"
      | "ChannelCloseConfirm"
      | "ChannelCloseConfirmError"
      | "ChannelCloseInit"
      | "ChannelCloseInitError"
      | "ChannelOpenAck"
      | "ChannelOpenAckError"
      | "ChannelOpenConfirm"
      | "ChannelOpenConfirmError"
      | "ChannelOpenInit"
      | "ChannelOpenInitError"
      | "ChannelOpenTry"
      | "ChannelOpenTryError"
      | "RecvPacket"
      | "SendPacket"
      | "Timeout"
      | "TimeoutError"
      | "WriteAckPacket"
      | "WriteTimeoutPacket"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "acknowledgement",
    values: [IbcPacketStruct, BytesLike, Ics23ProofStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "channelCloseConfirm",
    values: [AddressLike, BytesLike, Ics23ProofStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "channelCloseInit",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "channelOpenAck",
    values: [
      ChannelEndStruct,
      string[],
      BigNumberish,
      boolean,
      ChannelEndStruct,
      Ics23ProofStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "channelOpenConfirm",
    values: [
      ChannelEndStruct,
      string[],
      BigNumberish,
      boolean,
      ChannelEndStruct,
      Ics23ProofStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "channelOpenInit",
    values: [string, BigNumberish, boolean, string[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "channelOpenTry",
    values: [
      ChannelEndStruct,
      BigNumberish,
      boolean,
      string[],
      ChannelEndStruct,
      Ics23ProofStruct
    ]
  ): string;
  encodeFunctionData(functionFragment: "feeVault", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getChannel",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getOptimisticConsensusState",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "portPrefix",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "recvPacket",
    values: [IbcPacketStruct, Ics23ProofStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "removeConnection",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "sendPacket",
    values: [BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setClientForConnection",
    values: [string, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setPortPrefix",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "timeout",
    values: [IbcPacketStruct, Ics23ProofStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateClientWithOptimisticConsensusState",
    values: [BytesLike, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "writeTimeoutPacket",
    values: [IbcPacketStruct, Ics23ProofStruct]
  ): string;

  decodeFunctionResult(
    functionFragment: "acknowledgement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "channelCloseConfirm",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "channelCloseInit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "channelOpenAck",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "channelOpenConfirm",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "channelOpenInit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "channelOpenTry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "feeVault", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getChannel", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getOptimisticConsensusState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "portPrefix", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "recvPacket", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "removeConnection",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "sendPacket", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setClientForConnection",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPortPrefix",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "timeout", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateClientWithOptimisticConsensusState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "writeTimeoutPacket",
    data: BytesLike
  ): Result;
}

export namespace AcknowledgementEvent {
  export type InputTuple = [
    sourcePortAddress: AddressLike,
    sourceChannelId: BytesLike,
    sequence: BigNumberish
  ];
  export type OutputTuple = [
    sourcePortAddress: string,
    sourceChannelId: string,
    sequence: bigint
  ];
  export interface OutputObject {
    sourcePortAddress: string;
    sourceChannelId: string;
    sequence: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace AcknowledgementErrorEvent {
  export type InputTuple = [receiver: AddressLike, error: BytesLike];
  export type OutputTuple = [receiver: string, error: string];
  export interface OutputObject {
    receiver: string;
    error: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ChannelCloseConfirmEvent {
  export type InputTuple = [portAddress: AddressLike, channelId: BytesLike];
  export type OutputTuple = [portAddress: string, channelId: string];
  export interface OutputObject {
    portAddress: string;
    channelId: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ChannelCloseConfirmErrorEvent {
  export type InputTuple = [receiver: AddressLike, error: BytesLike];
  export type OutputTuple = [receiver: string, error: string];
  export interface OutputObject {
    receiver: string;
    error: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ChannelCloseInitEvent {
  export type InputTuple = [portAddress: AddressLike, channelId: BytesLike];
  export type OutputTuple = [portAddress: string, channelId: string];
  export interface OutputObject {
    portAddress: string;
    channelId: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ChannelCloseInitErrorEvent {
  export type InputTuple = [receiver: AddressLike, error: BytesLike];
  export type OutputTuple = [receiver: string, error: string];
  export interface OutputObject {
    receiver: string;
    error: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ChannelOpenAckEvent {
  export type InputTuple = [receiver: AddressLike, channelId: BytesLike];
  export type OutputTuple = [receiver: string, channelId: string];
  export interface OutputObject {
    receiver: string;
    channelId: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ChannelOpenAckErrorEvent {
  export type InputTuple = [receiver: AddressLike, error: BytesLike];
  export type OutputTuple = [receiver: string, error: string];
  export interface OutputObject {
    receiver: string;
    error: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ChannelOpenConfirmEvent {
  export type InputTuple = [receiver: AddressLike, channelId: BytesLike];
  export type OutputTuple = [receiver: string, channelId: string];
  export interface OutputObject {
    receiver: string;
    channelId: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ChannelOpenConfirmErrorEvent {
  export type InputTuple = [receiver: AddressLike, error: BytesLike];
  export type OutputTuple = [receiver: string, error: string];
  export interface OutputObject {
    receiver: string;
    error: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ChannelOpenInitEvent {
  export type InputTuple = [
    receiver: AddressLike,
    version: string,
    ordering: BigNumberish,
    feeEnabled: boolean,
    connectionHops: string[],
    counterpartyPortId: string
  ];
  export type OutputTuple = [
    receiver: string,
    version: string,
    ordering: bigint,
    feeEnabled: boolean,
    connectionHops: string[],
    counterpartyPortId: string
  ];
  export interface OutputObject {
    receiver: string;
    version: string;
    ordering: bigint;
    feeEnabled: boolean;
    connectionHops: string[];
    counterpartyPortId: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ChannelOpenInitErrorEvent {
  export type InputTuple = [receiver: AddressLike, error: BytesLike];
  export type OutputTuple = [receiver: string, error: string];
  export interface OutputObject {
    receiver: string;
    error: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ChannelOpenTryEvent {
  export type InputTuple = [
    receiver: AddressLike,
    version: string,
    ordering: BigNumberish,
    feeEnabled: boolean,
    connectionHops: string[],
    counterpartyPortId: string,
    counterpartyChannelId: BytesLike
  ];
  export type OutputTuple = [
    receiver: string,
    version: string,
    ordering: bigint,
    feeEnabled: boolean,
    connectionHops: string[],
    counterpartyPortId: string,
    counterpartyChannelId: string
  ];
  export interface OutputObject {
    receiver: string;
    version: string;
    ordering: bigint;
    feeEnabled: boolean;
    connectionHops: string[];
    counterpartyPortId: string;
    counterpartyChannelId: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ChannelOpenTryErrorEvent {
  export type InputTuple = [receiver: AddressLike, error: BytesLike];
  export type OutputTuple = [receiver: string, error: string];
  export interface OutputObject {
    receiver: string;
    error: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RecvPacketEvent {
  export type InputTuple = [
    destPortAddress: AddressLike,
    destChannelId: BytesLike,
    sequence: BigNumberish
  ];
  export type OutputTuple = [
    destPortAddress: string,
    destChannelId: string,
    sequence: bigint
  ];
  export interface OutputObject {
    destPortAddress: string;
    destChannelId: string;
    sequence: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SendPacketEvent {
  export type InputTuple = [
    sourcePortAddress: AddressLike,
    sourceChannelId: BytesLike,
    packet: BytesLike,
    sequence: BigNumberish,
    timeoutTimestamp: BigNumberish
  ];
  export type OutputTuple = [
    sourcePortAddress: string,
    sourceChannelId: string,
    packet: string,
    sequence: bigint,
    timeoutTimestamp: bigint
  ];
  export interface OutputObject {
    sourcePortAddress: string;
    sourceChannelId: string;
    packet: string;
    sequence: bigint;
    timeoutTimestamp: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TimeoutEvent {
  export type InputTuple = [
    sourcePortAddress: AddressLike,
    sourceChannelId: BytesLike,
    sequence: BigNumberish
  ];
  export type OutputTuple = [
    sourcePortAddress: string,
    sourceChannelId: string,
    sequence: bigint
  ];
  export interface OutputObject {
    sourcePortAddress: string;
    sourceChannelId: string;
    sequence: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TimeoutErrorEvent {
  export type InputTuple = [receiver: AddressLike, error: BytesLike];
  export type OutputTuple = [receiver: string, error: string];
  export interface OutputObject {
    receiver: string;
    error: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace WriteAckPacketEvent {
  export type InputTuple = [
    writerPortAddress: AddressLike,
    writerChannelId: BytesLike,
    sequence: BigNumberish,
    ackPacket: AckPacketStruct
  ];
  export type OutputTuple = [
    writerPortAddress: string,
    writerChannelId: string,
    sequence: bigint,
    ackPacket: AckPacketStructOutput
  ];
  export interface OutputObject {
    writerPortAddress: string;
    writerChannelId: string;
    sequence: bigint;
    ackPacket: AckPacketStructOutput;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace WriteTimeoutPacketEvent {
  export type InputTuple = [
    writerPortAddress: AddressLike,
    writerChannelId: BytesLike,
    sequence: BigNumberish,
    timeoutHeight: HeightStruct,
    timeoutTimestamp: BigNumberish
  ];
  export type OutputTuple = [
    writerPortAddress: string,
    writerChannelId: string,
    sequence: bigint,
    timeoutHeight: HeightStructOutput,
    timeoutTimestamp: bigint
  ];
  export interface OutputObject {
    writerPortAddress: string;
    writerChannelId: string;
    sequence: bigint;
    timeoutHeight: HeightStructOutput;
    timeoutTimestamp: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface IDispatcher extends BaseContract {
  connect(runner?: ContractRunner | null): IDispatcher;
  waitForDeployment(): Promise<this>;

  interface: IDispatcherInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  acknowledgement: TypedContractMethod<
    [packet: IbcPacketStruct, ack: BytesLike, proof: Ics23ProofStruct],
    [void],
    "nonpayable"
  >;

  channelCloseConfirm: TypedContractMethod<
    [portAddress: AddressLike, channelId: BytesLike, proof: Ics23ProofStruct],
    [void],
    "nonpayable"
  >;

  channelCloseInit: TypedContractMethod<
    [channelId: BytesLike],
    [void],
    "nonpayable"
  >;

  channelOpenAck: TypedContractMethod<
    [
      local: ChannelEndStruct,
      connectionHops: string[],
      ordering: BigNumberish,
      feeEnabled: boolean,
      counterparty: ChannelEndStruct,
      proof: Ics23ProofStruct
    ],
    [void],
    "nonpayable"
  >;

  channelOpenConfirm: TypedContractMethod<
    [
      local: ChannelEndStruct,
      connectionHops: string[],
      ordering: BigNumberish,
      feeEnabled: boolean,
      counterparty: ChannelEndStruct,
      proof: Ics23ProofStruct
    ],
    [void],
    "nonpayable"
  >;

  channelOpenInit: TypedContractMethod<
    [
      version: string,
      ordering: BigNumberish,
      feeEnabled: boolean,
      connectionHops: string[],
      counterpartyPortId: string
    ],
    [void],
    "nonpayable"
  >;

  channelOpenTry: TypedContractMethod<
    [
      local: ChannelEndStruct,
      ordering: BigNumberish,
      feeEnabled: boolean,
      connectionHops: string[],
      counterparty: ChannelEndStruct,
      proof: Ics23ProofStruct
    ],
    [void],
    "nonpayable"
  >;

  feeVault: TypedContractMethod<[], [string], "nonpayable">;

  getChannel: TypedContractMethod<
    [portAddress: AddressLike, channelId: BytesLike],
    [ChannelStructOutput],
    "view"
  >;

  getOptimisticConsensusState: TypedContractMethod<
    [height: BigNumberish, connection: string],
    [bigint],
    "view"
  >;

  portPrefix: TypedContractMethod<[], [string], "view">;

  recvPacket: TypedContractMethod<
    [packet: IbcPacketStruct, proof: Ics23ProofStruct],
    [void],
    "nonpayable"
  >;

  removeConnection: TypedContractMethod<
    [connection: string],
    [void],
    "nonpayable"
  >;

  sendPacket: TypedContractMethod<
    [channelId: BytesLike, packet: BytesLike, timeoutTimestamp: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  setClientForConnection: TypedContractMethod<
    [connection: string, lightClient: AddressLike],
    [void],
    "nonpayable"
  >;

  setPortPrefix: TypedContractMethod<
    [_portPrefix: string],
    [void],
    "nonpayable"
  >;

  timeout: TypedContractMethod<
    [packet: IbcPacketStruct, proof: Ics23ProofStruct],
    [void],
    "nonpayable"
  >;

  updateClientWithOptimisticConsensusState: TypedContractMethod<
    [
      proof: BytesLike,
      height: BigNumberish,
      appHash: BigNumberish,
      connection: string
    ],
    [void],
    "nonpayable"
  >;

  writeTimeoutPacket: TypedContractMethod<
    [packet: IbcPacketStruct, proof: Ics23ProofStruct],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "acknowledgement"
  ): TypedContractMethod<
    [packet: IbcPacketStruct, ack: BytesLike, proof: Ics23ProofStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "channelCloseConfirm"
  ): TypedContractMethod<
    [portAddress: AddressLike, channelId: BytesLike, proof: Ics23ProofStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "channelCloseInit"
  ): TypedContractMethod<[channelId: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "channelOpenAck"
  ): TypedContractMethod<
    [
      local: ChannelEndStruct,
      connectionHops: string[],
      ordering: BigNumberish,
      feeEnabled: boolean,
      counterparty: ChannelEndStruct,
      proof: Ics23ProofStruct
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "channelOpenConfirm"
  ): TypedContractMethod<
    [
      local: ChannelEndStruct,
      connectionHops: string[],
      ordering: BigNumberish,
      feeEnabled: boolean,
      counterparty: ChannelEndStruct,
      proof: Ics23ProofStruct
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "channelOpenInit"
  ): TypedContractMethod<
    [
      version: string,
      ordering: BigNumberish,
      feeEnabled: boolean,
      connectionHops: string[],
      counterpartyPortId: string
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "channelOpenTry"
  ): TypedContractMethod<
    [
      local: ChannelEndStruct,
      ordering: BigNumberish,
      feeEnabled: boolean,
      connectionHops: string[],
      counterparty: ChannelEndStruct,
      proof: Ics23ProofStruct
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "feeVault"
  ): TypedContractMethod<[], [string], "nonpayable">;
  getFunction(
    nameOrSignature: "getChannel"
  ): TypedContractMethod<
    [portAddress: AddressLike, channelId: BytesLike],
    [ChannelStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getOptimisticConsensusState"
  ): TypedContractMethod<
    [height: BigNumberish, connection: string],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "portPrefix"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "recvPacket"
  ): TypedContractMethod<
    [packet: IbcPacketStruct, proof: Ics23ProofStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "removeConnection"
  ): TypedContractMethod<[connection: string], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "sendPacket"
  ): TypedContractMethod<
    [channelId: BytesLike, packet: BytesLike, timeoutTimestamp: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setClientForConnection"
  ): TypedContractMethod<
    [connection: string, lightClient: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setPortPrefix"
  ): TypedContractMethod<[_portPrefix: string], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "timeout"
  ): TypedContractMethod<
    [packet: IbcPacketStruct, proof: Ics23ProofStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateClientWithOptimisticConsensusState"
  ): TypedContractMethod<
    [
      proof: BytesLike,
      height: BigNumberish,
      appHash: BigNumberish,
      connection: string
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "writeTimeoutPacket"
  ): TypedContractMethod<
    [packet: IbcPacketStruct, proof: Ics23ProofStruct],
    [void],
    "nonpayable"
  >;

  getEvent(
    key: "Acknowledgement"
  ): TypedContractEvent<
    AcknowledgementEvent.InputTuple,
    AcknowledgementEvent.OutputTuple,
    AcknowledgementEvent.OutputObject
  >;
  getEvent(
    key: "AcknowledgementError"
  ): TypedContractEvent<
    AcknowledgementErrorEvent.InputTuple,
    AcknowledgementErrorEvent.OutputTuple,
    AcknowledgementErrorEvent.OutputObject
  >;
  getEvent(
    key: "ChannelCloseConfirm"
  ): TypedContractEvent<
    ChannelCloseConfirmEvent.InputTuple,
    ChannelCloseConfirmEvent.OutputTuple,
    ChannelCloseConfirmEvent.OutputObject
  >;
  getEvent(
    key: "ChannelCloseConfirmError"
  ): TypedContractEvent<
    ChannelCloseConfirmErrorEvent.InputTuple,
    ChannelCloseConfirmErrorEvent.OutputTuple,
    ChannelCloseConfirmErrorEvent.OutputObject
  >;
  getEvent(
    key: "ChannelCloseInit"
  ): TypedContractEvent<
    ChannelCloseInitEvent.InputTuple,
    ChannelCloseInitEvent.OutputTuple,
    ChannelCloseInitEvent.OutputObject
  >;
  getEvent(
    key: "ChannelCloseInitError"
  ): TypedContractEvent<
    ChannelCloseInitErrorEvent.InputTuple,
    ChannelCloseInitErrorEvent.OutputTuple,
    ChannelCloseInitErrorEvent.OutputObject
  >;
  getEvent(
    key: "ChannelOpenAck"
  ): TypedContractEvent<
    ChannelOpenAckEvent.InputTuple,
    ChannelOpenAckEvent.OutputTuple,
    ChannelOpenAckEvent.OutputObject
  >;
  getEvent(
    key: "ChannelOpenAckError"
  ): TypedContractEvent<
    ChannelOpenAckErrorEvent.InputTuple,
    ChannelOpenAckErrorEvent.OutputTuple,
    ChannelOpenAckErrorEvent.OutputObject
  >;
  getEvent(
    key: "ChannelOpenConfirm"
  ): TypedContractEvent<
    ChannelOpenConfirmEvent.InputTuple,
    ChannelOpenConfirmEvent.OutputTuple,
    ChannelOpenConfirmEvent.OutputObject
  >;
  getEvent(
    key: "ChannelOpenConfirmError"
  ): TypedContractEvent<
    ChannelOpenConfirmErrorEvent.InputTuple,
    ChannelOpenConfirmErrorEvent.OutputTuple,
    ChannelOpenConfirmErrorEvent.OutputObject
  >;
  getEvent(
    key: "ChannelOpenInit"
  ): TypedContractEvent<
    ChannelOpenInitEvent.InputTuple,
    ChannelOpenInitEvent.OutputTuple,
    ChannelOpenInitEvent.OutputObject
  >;
  getEvent(
    key: "ChannelOpenInitError"
  ): TypedContractEvent<
    ChannelOpenInitErrorEvent.InputTuple,
    ChannelOpenInitErrorEvent.OutputTuple,
    ChannelOpenInitErrorEvent.OutputObject
  >;
  getEvent(
    key: "ChannelOpenTry"
  ): TypedContractEvent<
    ChannelOpenTryEvent.InputTuple,
    ChannelOpenTryEvent.OutputTuple,
    ChannelOpenTryEvent.OutputObject
  >;
  getEvent(
    key: "ChannelOpenTryError"
  ): TypedContractEvent<
    ChannelOpenTryErrorEvent.InputTuple,
    ChannelOpenTryErrorEvent.OutputTuple,
    ChannelOpenTryErrorEvent.OutputObject
  >;
  getEvent(
    key: "RecvPacket"
  ): TypedContractEvent<
    RecvPacketEvent.InputTuple,
    RecvPacketEvent.OutputTuple,
    RecvPacketEvent.OutputObject
  >;
  getEvent(
    key: "SendPacket"
  ): TypedContractEvent<
    SendPacketEvent.InputTuple,
    SendPacketEvent.OutputTuple,
    SendPacketEvent.OutputObject
  >;
  getEvent(
    key: "Timeout"
  ): TypedContractEvent<
    TimeoutEvent.InputTuple,
    TimeoutEvent.OutputTuple,
    TimeoutEvent.OutputObject
  >;
  getEvent(
    key: "TimeoutError"
  ): TypedContractEvent<
    TimeoutErrorEvent.InputTuple,
    TimeoutErrorEvent.OutputTuple,
    TimeoutErrorEvent.OutputObject
  >;
  getEvent(
    key: "WriteAckPacket"
  ): TypedContractEvent<
    WriteAckPacketEvent.InputTuple,
    WriteAckPacketEvent.OutputTuple,
    WriteAckPacketEvent.OutputObject
  >;
  getEvent(
    key: "WriteTimeoutPacket"
  ): TypedContractEvent<
    WriteTimeoutPacketEvent.InputTuple,
    WriteTimeoutPacketEvent.OutputTuple,
    WriteTimeoutPacketEvent.OutputObject
  >;

  filters: {
    "Acknowledgement(address,bytes32,uint64)": TypedContractEvent<
      AcknowledgementEvent.InputTuple,
      AcknowledgementEvent.OutputTuple,
      AcknowledgementEvent.OutputObject
    >;
    Acknowledgement: TypedContractEvent<
      AcknowledgementEvent.InputTuple,
      AcknowledgementEvent.OutputTuple,
      AcknowledgementEvent.OutputObject
    >;

    "AcknowledgementError(address,bytes)": TypedContractEvent<
      AcknowledgementErrorEvent.InputTuple,
      AcknowledgementErrorEvent.OutputTuple,
      AcknowledgementErrorEvent.OutputObject
    >;
    AcknowledgementError: TypedContractEvent<
      AcknowledgementErrorEvent.InputTuple,
      AcknowledgementErrorEvent.OutputTuple,
      AcknowledgementErrorEvent.OutputObject
    >;

    "ChannelCloseConfirm(address,bytes32)": TypedContractEvent<
      ChannelCloseConfirmEvent.InputTuple,
      ChannelCloseConfirmEvent.OutputTuple,
      ChannelCloseConfirmEvent.OutputObject
    >;
    ChannelCloseConfirm: TypedContractEvent<
      ChannelCloseConfirmEvent.InputTuple,
      ChannelCloseConfirmEvent.OutputTuple,
      ChannelCloseConfirmEvent.OutputObject
    >;

    "ChannelCloseConfirmError(address,bytes)": TypedContractEvent<
      ChannelCloseConfirmErrorEvent.InputTuple,
      ChannelCloseConfirmErrorEvent.OutputTuple,
      ChannelCloseConfirmErrorEvent.OutputObject
    >;
    ChannelCloseConfirmError: TypedContractEvent<
      ChannelCloseConfirmErrorEvent.InputTuple,
      ChannelCloseConfirmErrorEvent.OutputTuple,
      ChannelCloseConfirmErrorEvent.OutputObject
    >;

    "ChannelCloseInit(address,bytes32)": TypedContractEvent<
      ChannelCloseInitEvent.InputTuple,
      ChannelCloseInitEvent.OutputTuple,
      ChannelCloseInitEvent.OutputObject
    >;
    ChannelCloseInit: TypedContractEvent<
      ChannelCloseInitEvent.InputTuple,
      ChannelCloseInitEvent.OutputTuple,
      ChannelCloseInitEvent.OutputObject
    >;

    "ChannelCloseInitError(address,bytes)": TypedContractEvent<
      ChannelCloseInitErrorEvent.InputTuple,
      ChannelCloseInitErrorEvent.OutputTuple,
      ChannelCloseInitErrorEvent.OutputObject
    >;
    ChannelCloseInitError: TypedContractEvent<
      ChannelCloseInitErrorEvent.InputTuple,
      ChannelCloseInitErrorEvent.OutputTuple,
      ChannelCloseInitErrorEvent.OutputObject
    >;

    "ChannelOpenAck(address,bytes32)": TypedContractEvent<
      ChannelOpenAckEvent.InputTuple,
      ChannelOpenAckEvent.OutputTuple,
      ChannelOpenAckEvent.OutputObject
    >;
    ChannelOpenAck: TypedContractEvent<
      ChannelOpenAckEvent.InputTuple,
      ChannelOpenAckEvent.OutputTuple,
      ChannelOpenAckEvent.OutputObject
    >;

    "ChannelOpenAckError(address,bytes)": TypedContractEvent<
      ChannelOpenAckErrorEvent.InputTuple,
      ChannelOpenAckErrorEvent.OutputTuple,
      ChannelOpenAckErrorEvent.OutputObject
    >;
    ChannelOpenAckError: TypedContractEvent<
      ChannelOpenAckErrorEvent.InputTuple,
      ChannelOpenAckErrorEvent.OutputTuple,
      ChannelOpenAckErrorEvent.OutputObject
    >;

    "ChannelOpenConfirm(address,bytes32)": TypedContractEvent<
      ChannelOpenConfirmEvent.InputTuple,
      ChannelOpenConfirmEvent.OutputTuple,
      ChannelOpenConfirmEvent.OutputObject
    >;
    ChannelOpenConfirm: TypedContractEvent<
      ChannelOpenConfirmEvent.InputTuple,
      ChannelOpenConfirmEvent.OutputTuple,
      ChannelOpenConfirmEvent.OutputObject
    >;

    "ChannelOpenConfirmError(address,bytes)": TypedContractEvent<
      ChannelOpenConfirmErrorEvent.InputTuple,
      ChannelOpenConfirmErrorEvent.OutputTuple,
      ChannelOpenConfirmErrorEvent.OutputObject
    >;
    ChannelOpenConfirmError: TypedContractEvent<
      ChannelOpenConfirmErrorEvent.InputTuple,
      ChannelOpenConfirmErrorEvent.OutputTuple,
      ChannelOpenConfirmErrorEvent.OutputObject
    >;

    "ChannelOpenInit(address,string,uint8,bool,string[],string)": TypedContractEvent<
      ChannelOpenInitEvent.InputTuple,
      ChannelOpenInitEvent.OutputTuple,
      ChannelOpenInitEvent.OutputObject
    >;
    ChannelOpenInit: TypedContractEvent<
      ChannelOpenInitEvent.InputTuple,
      ChannelOpenInitEvent.OutputTuple,
      ChannelOpenInitEvent.OutputObject
    >;

    "ChannelOpenInitError(address,bytes)": TypedContractEvent<
      ChannelOpenInitErrorEvent.InputTuple,
      ChannelOpenInitErrorEvent.OutputTuple,
      ChannelOpenInitErrorEvent.OutputObject
    >;
    ChannelOpenInitError: TypedContractEvent<
      ChannelOpenInitErrorEvent.InputTuple,
      ChannelOpenInitErrorEvent.OutputTuple,
      ChannelOpenInitErrorEvent.OutputObject
    >;

    "ChannelOpenTry(address,string,uint8,bool,string[],string,bytes32)": TypedContractEvent<
      ChannelOpenTryEvent.InputTuple,
      ChannelOpenTryEvent.OutputTuple,
      ChannelOpenTryEvent.OutputObject
    >;
    ChannelOpenTry: TypedContractEvent<
      ChannelOpenTryEvent.InputTuple,
      ChannelOpenTryEvent.OutputTuple,
      ChannelOpenTryEvent.OutputObject
    >;

    "ChannelOpenTryError(address,bytes)": TypedContractEvent<
      ChannelOpenTryErrorEvent.InputTuple,
      ChannelOpenTryErrorEvent.OutputTuple,
      ChannelOpenTryErrorEvent.OutputObject
    >;
    ChannelOpenTryError: TypedContractEvent<
      ChannelOpenTryErrorEvent.InputTuple,
      ChannelOpenTryErrorEvent.OutputTuple,
      ChannelOpenTryErrorEvent.OutputObject
    >;

    "RecvPacket(address,bytes32,uint64)": TypedContractEvent<
      RecvPacketEvent.InputTuple,
      RecvPacketEvent.OutputTuple,
      RecvPacketEvent.OutputObject
    >;
    RecvPacket: TypedContractEvent<
      RecvPacketEvent.InputTuple,
      RecvPacketEvent.OutputTuple,
      RecvPacketEvent.OutputObject
    >;

    "SendPacket(address,bytes32,bytes,uint64,uint64)": TypedContractEvent<
      SendPacketEvent.InputTuple,
      SendPacketEvent.OutputTuple,
      SendPacketEvent.OutputObject
    >;
    SendPacket: TypedContractEvent<
      SendPacketEvent.InputTuple,
      SendPacketEvent.OutputTuple,
      SendPacketEvent.OutputObject
    >;

    "Timeout(address,bytes32,uint64)": TypedContractEvent<
      TimeoutEvent.InputTuple,
      TimeoutEvent.OutputTuple,
      TimeoutEvent.OutputObject
    >;
    Timeout: TypedContractEvent<
      TimeoutEvent.InputTuple,
      TimeoutEvent.OutputTuple,
      TimeoutEvent.OutputObject
    >;

    "TimeoutError(address,bytes)": TypedContractEvent<
      TimeoutErrorEvent.InputTuple,
      TimeoutErrorEvent.OutputTuple,
      TimeoutErrorEvent.OutputObject
    >;
    TimeoutError: TypedContractEvent<
      TimeoutErrorEvent.InputTuple,
      TimeoutErrorEvent.OutputTuple,
      TimeoutErrorEvent.OutputObject
    >;

    "WriteAckPacket(address,bytes32,uint64,tuple)": TypedContractEvent<
      WriteAckPacketEvent.InputTuple,
      WriteAckPacketEvent.OutputTuple,
      WriteAckPacketEvent.OutputObject
    >;
    WriteAckPacket: TypedContractEvent<
      WriteAckPacketEvent.InputTuple,
      WriteAckPacketEvent.OutputTuple,
      WriteAckPacketEvent.OutputObject
    >;

    "WriteTimeoutPacket(address,bytes32,uint64,tuple,uint64)": TypedContractEvent<
      WriteTimeoutPacketEvent.InputTuple,
      WriteTimeoutPacketEvent.OutputTuple,
      WriteTimeoutPacketEvent.OutputObject
    >;
    WriteTimeoutPacket: TypedContractEvent<
      WriteTimeoutPacketEvent.InputTuple,
      WriteTimeoutPacketEvent.OutputTuple,
      WriteTimeoutPacketEvent.OutputObject
    >;
  };
}
