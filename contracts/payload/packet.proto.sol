// File automatically generated by protoc-gen-sol v0.2.0
// SPDX-License-Identifier: NONE
pragma solidity >=0.6.0 <8.0.0;
pragma experimental ABIEncoderV2;

import "@lazyledger/protobuf3-solidity-lib/contracts/ProtobufLib.sol";

struct Height {
    uint64 revision_number;
    uint64 revision_height;
}

library HeightCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len) internal pure returns (bool, uint64, Height memory) {
        // Message instance
        Height memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 2) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 2) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        return false;
    }

    function decode_field(uint64 initial_pos, bytes memory buf, uint64 len, uint64 field_number, Height memory instance) internal pure returns (bool, uint64) {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 2) {
            bool success;
            (success, pos) = decode_2(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // Height.revision_number
    function decode_1(uint64 pos, bytes memory buf, Height memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.revision_number = v;

        return (true, pos);
    }

    // Height.revision_height
    function decode_2(uint64 pos, bytes memory buf, Height memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.revision_height = v;

        return (true, pos);
    }

    // Holds encoded version of message
    struct Height__Encoded {
        bytes revision_number__Key;
        bytes revision_number;
        bytes revision_height__Key;
        bytes revision_height;
    }

    // Holds encoded version of nested message
    struct Height__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(Height memory instance) internal pure returns (bytes memory) {
        Height__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding revision_number if default value
        if (uint64(instance.revision_number) != 0) {
            // Encode key for revision_number
            encodedInstance.revision_number__Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.Varint));
            // Encode revision_number
            encodedInstance.revision_number = ProtobufLib.encode_uint64(instance.revision_number);
        }

        // Omit encoding revision_height if default value
        if (uint64(instance.revision_height) != 0) {
            // Encode key for revision_height
            encodedInstance.revision_height__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.Varint));
            // Encode revision_height
            encodedInstance.revision_height = ProtobufLib.encode_uint64(instance.revision_height);
        }

        bytes memory finalEncoded;
        index = 0;
        len = 0;
        len += uint64(encodedInstance.revision_number.length);
        len += uint64(encodedInstance.revision_height.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.revision_number.length) {
            finalEncoded[index++] = encodedInstance.revision_number[j];
        }
        j = 0;
        while (j < encodedInstance.revision_height.length) {
            finalEncoded[index++] = encodedInstance.revision_height[j];
        }

        return finalEncoded;
    }

    // Encode a nested Height, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, Height memory instance) internal pure returns (Height__Encoded__Nested memory) {
        Height__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }

}

struct Packet {
    uint64 sequence;
    string source_port;
    string source_channel;
    string destination_port;
    string destination_channel;
    bytes data;
    Height timeout_height;
    uint64 timeout_timestamp;
}

library PacketCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len) internal pure returns (bool, uint64, Packet memory) {
        // Message instance
        Packet memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 8) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 2) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 3) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 4) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 5) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 6) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 7) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 8) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        return false;
    }

    function decode_field(uint64 initial_pos, bytes memory buf, uint64 len, uint64 field_number, Packet memory instance) internal pure returns (bool, uint64) {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 2) {
            bool success;
            (success, pos) = decode_2(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 3) {
            bool success;
            (success, pos) = decode_3(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 4) {
            bool success;
            (success, pos) = decode_4(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 5) {
            bool success;
            (success, pos) = decode_5(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 6) {
            bool success;
            (success, pos) = decode_6(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 7) {
            bool success;
            (success, pos) = decode_7(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 8) {
            bool success;
            (success, pos) = decode_8(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // Packet.sequence
    function decode_1(uint64 pos, bytes memory buf, Packet memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.sequence = v;

        return (true, pos);
    }

    // Packet.source_port
    function decode_2(uint64 pos, bytes memory buf, Packet memory instance) internal pure returns (bool, uint64) {
        bool success;

        string memory v;
        (success, pos, v) = ProtobufLib.decode_string(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (bytes(v).length == 0) {
            return (false, pos);
        }

        instance.source_port = v;

        return (true, pos);
    }

    // Packet.source_channel
    function decode_3(uint64 pos, bytes memory buf, Packet memory instance) internal pure returns (bool, uint64) {
        bool success;

        string memory v;
        (success, pos, v) = ProtobufLib.decode_string(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (bytes(v).length == 0) {
            return (false, pos);
        }

        instance.source_channel = v;

        return (true, pos);
    }

    // Packet.destination_port
    function decode_4(uint64 pos, bytes memory buf, Packet memory instance) internal pure returns (bool, uint64) {
        bool success;

        string memory v;
        (success, pos, v) = ProtobufLib.decode_string(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (bytes(v).length == 0) {
            return (false, pos);
        }

        instance.destination_port = v;

        return (true, pos);
    }

    // Packet.destination_channel
    function decode_5(uint64 pos, bytes memory buf, Packet memory instance) internal pure returns (bool, uint64) {
        bool success;

        string memory v;
        (success, pos, v) = ProtobufLib.decode_string(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (bytes(v).length == 0) {
            return (false, pos);
        }

        instance.destination_channel = v;

        return (true, pos);
    }

    // Packet.data
    function decode_6(uint64 pos, bytes memory buf, Packet memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.data = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.data[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // Packet.timeout_height
    function decode_7(uint64 pos, bytes memory buf, Packet memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_embedded_message(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        Height memory nestedInstance;
        (success, pos, nestedInstance) = HeightCodec.decode(pos, buf, len);
        if (!success) {
            return (false, pos);
        }

        instance.timeout_height = nestedInstance;

        return (true, pos);
    }

    // Packet.timeout_timestamp
    function decode_8(uint64 pos, bytes memory buf, Packet memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.timeout_timestamp = v;

        return (true, pos);
    }

    // Holds encoded version of message
    struct Packet__Encoded {
        bytes sequence__Key;
        bytes sequence;
        bytes source_port__Key;
        bytes source_port__Length;
        bytes source_port;
        bytes source_channel__Key;
        bytes source_channel__Length;
        bytes source_channel;
        bytes destination_port__Key;
        bytes destination_port__Length;
        bytes destination_port;
        bytes destination_channel__Key;
        bytes destination_channel__Length;
        bytes destination_channel;
        bytes data__Key;
        bytes data__Length;
        bytes data;
        HeightCodec.Height__Encoded__Nested timeout_height;
        bytes timeout_height__Encoded;
        bytes timeout_timestamp__Key;
        bytes timeout_timestamp;
    }

    // Holds encoded version of nested message
    struct Packet__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(Packet memory instance) internal pure returns (bytes memory) {
        Packet__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding sequence if default value
        if (uint64(instance.sequence) != 0) {
            // Encode key for sequence
            encodedInstance.sequence__Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.Varint));
            // Encode sequence
            encodedInstance.sequence = ProtobufLib.encode_uint64(instance.sequence);
        }

        // Omit encoding source_port if default value
        if (bytes(instance.source_port).length > 0) {
            // Encode key for source_port
            encodedInstance.source_port__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode source_port
            encodedInstance.source_port__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.source_port).length));
            encodedInstance.source_port = bytes(instance.source_port);
        }

        // Omit encoding source_channel if default value
        if (bytes(instance.source_channel).length > 0) {
            // Encode key for source_channel
            encodedInstance.source_channel__Key = ProtobufLib.encode_key(3, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode source_channel
            encodedInstance.source_channel__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.source_channel).length));
            encodedInstance.source_channel = bytes(instance.source_channel);
        }

        // Omit encoding destination_port if default value
        if (bytes(instance.destination_port).length > 0) {
            // Encode key for destination_port
            encodedInstance.destination_port__Key = ProtobufLib.encode_key(4, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode destination_port
            encodedInstance.destination_port__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.destination_port).length));
            encodedInstance.destination_port = bytes(instance.destination_port);
        }

        // Omit encoding destination_channel if default value
        if (bytes(instance.destination_channel).length > 0) {
            // Encode key for destination_channel
            encodedInstance.destination_channel__Key = ProtobufLib.encode_key(5, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode destination_channel
            encodedInstance.destination_channel__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.destination_channel).length));
            encodedInstance.destination_channel = bytes(instance.destination_channel);
        }

        // Omit encoding data if default value
        if (bytes(instance.data).length > 0) {
            // Encode key for data
            encodedInstance.data__Key = ProtobufLib.encode_key(6, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode data
            encodedInstance.data__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.data).length));
            encodedInstance.data = bytes(instance.data);
        }

        // Encode timeout_height
        encodedInstance.timeout_height = HeightCodec.encodeNested(7, instance.timeout_height);
        encodedInstance.timeout_height__Encoded = abi.encodePacked(encodedInstance.timeout_height.key, encodedInstance.timeout_height.length, encodedInstance.timeout_height.nestedInstance);

        // Omit encoding timeout_timestamp if default value
        if (uint64(instance.timeout_timestamp) != 0) {
            // Encode key for timeout_timestamp
            encodedInstance.timeout_timestamp__Key = ProtobufLib.encode_key(8, uint64(ProtobufLib.WireType.Varint));
            // Encode timeout_timestamp
            encodedInstance.timeout_timestamp = ProtobufLib.encode_uint64(instance.timeout_timestamp);
        }

        bytes memory finalEncoded;
        index = 0;
        len = 0;
        len += uint64(encodedInstance.sequence.length);
        len += uint64(encodedInstance.source_port.length);
        len += uint64(encodedInstance.source_channel.length);
        len += uint64(encodedInstance.destination_port.length);
        len += uint64(encodedInstance.destination_channel.length);
        len += uint64(encodedInstance.data.length);
        len += uint64(encodedInstance.timeout_height__Encoded.length);
        len += uint64(encodedInstance.timeout_timestamp.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.sequence.length) {
            finalEncoded[index++] = encodedInstance.sequence[j];
        }
        j = 0;
        while (j < encodedInstance.source_port.length) {
            finalEncoded[index++] = encodedInstance.source_port[j];
        }
        j = 0;
        while (j < encodedInstance.source_channel.length) {
            finalEncoded[index++] = encodedInstance.source_channel[j];
        }
        j = 0;
        while (j < encodedInstance.destination_port.length) {
            finalEncoded[index++] = encodedInstance.destination_port[j];
        }
        j = 0;
        while (j < encodedInstance.destination_channel.length) {
            finalEncoded[index++] = encodedInstance.destination_channel[j];
        }
        j = 0;
        while (j < encodedInstance.data.length) {
            finalEncoded[index++] = encodedInstance.data[j];
        }
        j = 0;
        while (j < encodedInstance.timeout_height__Encoded.length) {
            finalEncoded[index++] = encodedInstance.timeout_height__Encoded[j];
        }
        j = 0;
        while (j < encodedInstance.timeout_timestamp.length) {
            finalEncoded[index++] = encodedInstance.timeout_timestamp[j];
        }

        return finalEncoded;
    }

    // Encode a nested Packet, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, Packet memory instance) internal pure returns (Packet__Encoded__Nested memory) {
        Packet__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }

}

